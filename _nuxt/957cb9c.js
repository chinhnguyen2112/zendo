(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{102:function(e,t,r){"use strict";r.d(t,"a",(function(){return E})),r.d(t,"b",(function(){return w})),r.d(t,"c",(function(){return D})),r.d(t,"d",(function(){return U}));var o=r(173),n=r(2),h=r(271),c=r(272),l=r(170);const d=e=>null==e,f=e=>!d(e),m=(e,a,b)=>y(a,e)===y(b,e);function k(u){return u&&u.length&&new RegExp(["^\\/([a-zA-Z0-9@\\-%_~.:]","[/a-zA-Z0-9@\\-%_~.:]*)?","([?][^#]*)?(#[^#]*)?$"].join("")).test(u)}function x(e,t,r){return e.matched.some((e=>Object.values(e.components).some((component=>component.options&&component.options[t]===r))))}function y(path="",e){let t=path.split("?")[0];return e&&e.base&&(t=t.replace(e.base,"/")),"/"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),t=t.replace(/\/+/g,"/"),t}function v(e){return"string"==typeof e?e:JSON.stringify(e)}function _(e){if("string"==typeof e)try{return JSON.parse(e)}catch(e){}return e}function $(e,t){if(!t||!e||"object"!=typeof e)return e;if(t in e)return e[t];const r=Array.isArray(t)?t:(t+"").split(".");let o=e;for(;r.length&&o;)o=o[r.shift()];return o}function S(e,t){return e&&t&&"string"==typeof e&&!e.startsWith(t)?t+" "+e:e}class T{constructor(e,t){this.ctx=e,this.options=t,this._initState()}setUniversal(e,t){return d(t)?this.removeUniversal(e):(this.setCookie(e,t),this.setLocalStorage(e,t),this.setState(e,t),t)}getUniversal(e){let t;return d(t)&&(t=this.getCookie(e)),d(t)&&(t=this.getLocalStorage(e)),d(t)&&(t=this.getState(e)),t}syncUniversal(e,t){let r=this.getUniversal(e);return d(r)&&f(t)&&(r=t),f(r)&&this.setUniversal(e,r),r}removeUniversal(e){this.removeState(e),this.removeLocalStorage(e),this.removeCookie(e)}_initState(){if(n.set(this,"_state",{}),this._useVuex=this.options.vuex&&!!this.ctx.store,this._useVuex){const e={namespaced:!0,state:()=>this.options.initialState,mutations:{SET(e,t){n.set(e,t.key,t.value)}}};this.ctx.store.registerModule(this.options.vuex.namespace,e,{preserveState:Boolean(this.ctx.store.state[this.options.vuex.namespace])}),this.state=this.ctx.store.state[this.options.vuex.namespace]}else n.set(this,"state",{}),console.warn("[AUTH] The Vuex Store is not activated. This might cause issues in auth module behavior, like redirects not working properly.To activate it, see https://nuxtjs.org/docs/2.x/directory-structure/store")}setState(e,t){return"_"===e[0]?n.set(this._state,e,t):this._useVuex?this.ctx.store.commit(this.options.vuex.namespace+"/SET",{key:e,value:t}):n.set(this.state,e,t),t}getState(e){return"_"!==e[0]?this.state[e]:this._state[e]}watchState(e,t){if(this._useVuex)return this.ctx.store.watch((t=>$(t[this.options.vuex.namespace],e)),t)}removeState(e){this.setState(e,void 0)}setLocalStorage(e,t){if(d(t))return this.removeLocalStorage(e);if("undefined"==typeof localStorage||!this.options.localStorage)return;const r=this.options.localStorage.prefix+e;try{localStorage.setItem(r,v(t))}catch(e){if(!this.options.ignoreExceptions)throw e}return t}getLocalStorage(e){if("undefined"==typeof localStorage||!this.options.localStorage)return;const t=this.options.localStorage.prefix+e;return _(localStorage.getItem(t))}removeLocalStorage(e){if("undefined"==typeof localStorage||!this.options.localStorage)return;const t=this.options.localStorage.prefix+e;localStorage.removeItem(t)}getCookies(){const e=document.cookie;return h.parse(e||"")||{}}setCookie(e,t,r={}){if(!this.options.cookie)return;const o=(void 0!==r.prefix?r.prefix:this.options.cookie.prefix)+e,n=Object.assign({},this.options.cookie.options,r),c=v(t);d(t)&&(n.maxAge=-1),"number"==typeof n.expires&&(n.expires=new Date(Date.now()+864e5*n.expires));const l=h.serialize(o,c,n);return document.cookie=l,t}getCookie(e){if(!this.options.cookie)return;const t=this.options.cookie.prefix+e,r=this.getCookies();return _(r[t]?decodeURIComponent(r[t]):void 0)}removeCookie(e,t){this.setCookie(e,void 0,t)}}class E{constructor(e,t){this.strategies={},this._errorListeners=[],this._redirectListeners=[],this.ctx=e,this.options=t;const r=new T(e,{...t,initialState:{user:null,loggedIn:!1}});this.$storage=r,this.$state=r.state}get state(){return this._stateWarnShown||(this._stateWarnShown=!0,console.warn("[AUTH] $auth.state is deprecated. Please use $auth.$state or top level props like $auth.loggedIn")),this.$state}get strategy(){return this.getStrategy()}getStrategy(e=!0){if(e){if(!this.$state.strategy)throw new Error("No strategy is set!");if(!this.strategies[this.$state.strategy])throw new Error("Strategy not supported: "+this.$state.strategy)}return this.strategies[this.$state.strategy]}get user(){return this.$state.user}get loggedIn(){return this.$state.loggedIn}get busy(){return this.$storage.getState("busy")}async init(){if(this.options.resetOnError&&this.onError(((...e)=>{("function"!=typeof this.options.resetOnError||this.options.resetOnError(...e))&&this.reset()})),this.$storage.syncUniversal("strategy",this.options.defaultStrategy),!this.getStrategy(!1)&&(this.$storage.setUniversal("strategy",this.options.defaultStrategy),!this.getStrategy(!1)))return Promise.resolve();try{await this.mounted()}catch(e){this.callOnError(e)}finally{this.options.watchLoggedIn&&this.$storage.watchState("loggedIn",(e=>{x(this.ctx.route,"auth",!1)||this.redirect(e?"home":"logout")}))}}getState(e){return this._getStateWarnShown||(this._getStateWarnShown=!0,console.warn("[AUTH] $auth.getState is deprecated. Please use $auth.$storage.getState() or top level props like $auth.loggedIn")),this.$storage.getState(e)}registerStrategy(e,t){this.strategies[e]=t}setStrategy(e){if(e===this.$storage.getUniversal("strategy"))return Promise.resolve();if(!this.strategies[e])throw new Error(`Strategy ${e} is not defined!`);return this.reset(),this.$storage.setUniversal("strategy",e),this.mounted()}mounted(...e){return this.getStrategy().mounted?Promise.resolve(this.getStrategy().mounted(...e)).catch((e=>(this.callOnError(e,{method:"mounted"}),Promise.reject(e)))):this.fetchUserOnce()}loginWith(e,...t){return this.setStrategy(e).then((()=>this.login(...t)))}login(...e){return this.getStrategy().login?this.wrapLogin(this.getStrategy().login(...e)).catch((e=>(this.callOnError(e,{method:"login"}),Promise.reject(e)))):Promise.resolve()}fetchUser(...e){return this.getStrategy().fetchUser?Promise.resolve(this.getStrategy().fetchUser(...e)).catch((e=>(this.callOnError(e,{method:"fetchUser"}),Promise.reject(e)))):Promise.resolve()}logout(...e){return this.getStrategy().logout?Promise.resolve(this.getStrategy().logout(...e)).catch((e=>(this.callOnError(e,{method:"logout"}),Promise.reject(e)))):(this.reset(),Promise.resolve())}setUserToken(e,t){return this.getStrategy().setUserToken?Promise.resolve(this.getStrategy().setUserToken(e,t)).catch((e=>(this.callOnError(e,{method:"setUserToken"}),Promise.reject(e)))):(this.getStrategy().token.set(e),Promise.resolve())}reset(...e){return this.getStrategy().reset||(this.setUser(!1),this.getStrategy().token.reset(),this.getStrategy().refreshToken.reset()),this.getStrategy().reset(...e)}refreshTokens(){return this.getStrategy().refreshController?Promise.resolve(this.getStrategy().refreshController.handleRefresh()).catch((e=>(this.callOnError(e,{method:"refreshTokens"}),Promise.reject(e)))):Promise.resolve()}check(...e){return this.getStrategy().check?this.getStrategy().check(...e):{valid:!0}}fetchUserOnce(...e){return this.$state.user?Promise.resolve():this.fetchUser(...e)}setUser(e){this.$storage.setState("user",e);let t={valid:Boolean(e)};t.valid&&(t=this.check()),this.$storage.setState("loggedIn",t.valid)}request(e,t={}){const r="object"==typeof t?Object.assign({},t,e):e;if(""===r.baseURL&&(r.baseURL=o(this.ctx.req)),this.ctx.app.$axios)return this.ctx.app.$axios.request(r).catch((e=>(this.callOnError(e,{method:"request"}),Promise.reject(e))));console.error("[AUTH] add the @nuxtjs/axios module to nuxt.config file")}requestWith(e,t,r){const o=this.getStrategy().token.get(),n=Object.assign({},r,t),h=this.strategies[e].options.token.name||"Authorization";return n.headers||(n.headers={}),!n.headers[h]&&f(o)&&o&&"string"==typeof o&&(n.headers[h]=o),this.request(n)}wrapLogin(e){return this.$storage.setState("busy",!0),this.error=null,Promise.resolve(e).then((e=>(this.$storage.setState("busy",!1),e))).catch((e=>(this.$storage.setState("busy",!1),Promise.reject(e))))}onError(e){this._errorListeners.push(e)}callOnError(e,t={}){this.error=e;for(const r of this._errorListeners)r(e,t)}redirect(e,t=!1){if(!this.options.redirect)return;const r=this.options.fullPathRedirect?this.ctx.route.fullPath:this.ctx.route.path;let o=this.options.redirect[e];if(o){if(this.options.rewriteRedirects&&("login"===e&&k(r)&&!m(this.ctx,o,r)&&this.$storage.setUniversal("redirect",r),"home"===e)){const e=this.$storage.getUniversal("redirect");this.$storage.setUniversal("redirect",null),k(e)&&(o=e)}o=this.callOnRedirect(o,r)||o,m(this.ctx,o,r)||(t?(k(o)&&!o.includes(this.ctx.base)&&(o=y("/"+this.ctx.base+"/"+o)),window.location.replace(o)):this.ctx.redirect(o,this.ctx.query))}}onRedirect(e){this._redirectListeners.push(e)}callOnRedirect(e,t){for(const r of this._redirectListeners)e=r(e,t)||e;return e}hasScope(e){const t=this.$state.user&&$(this.$state.user,this.options.scopeKey);return!!t&&(Array.isArray(t)?t.includes(e):Boolean($(t,e)))}}const U=async e=>{if(x(e.route,"auth",!1))return;const t=function(e,t=[]){return[].concat(...e.matched.map((function(e,r){return Object.keys(e.components).map((function(o){return t.push(r),e.components[o]}))})))}(e.route,[]);if(!t.length)return;const{login:r,callback:o}=e.$auth.options.redirect,n=x(e.route,"auth","guest"),h=t=>y(e.route.path,e)===y(t,e);if(e.$auth.$state.loggedIn){const{tokenExpired:t,refreshTokenExpired:o,isRefreshable:c}=e.$auth.check(!0);if((!r||h(r)||n)&&e.$auth.redirect("home"),o)e.$auth.reset();else if(t)if(c)try{await e.$auth.refreshTokens()}catch(t){e.$auth.reset()}else e.$auth.reset()}else n||o&&h(o)||e.$auth.redirect("login")};class w extends Error{constructor(){super("Both token and refresh token have expired. Your request was aborted."),this.name="ExpiredAuthSessionError"}}class P{constructor(e){this.scheme=e,this._refreshPromise=null,this.$auth=e.$auth}handleRefresh(){return this._refreshPromise?this._refreshPromise:this._doRefresh()}_doRefresh(){return this._refreshPromise=new Promise(((e,t)=>{this.scheme.refreshTokens().then((t=>{this._refreshPromise=null,e(t)})).catch((e=>{this._refreshPromise=null,t(e)}))})),this._refreshPromise}}var I,O;(O=I||(I={})).UNKNOWN="UNKNOWN",O.VALID="VALID",O.EXPIRED="EXPIRED";class R{constructor(e,t){this._status=this._calculate(e,t)}unknown(){return I.UNKNOWN===this._status}valid(){return I.VALID===this._status}expired(){return I.EXPIRED===this._status}_calculate(e,t){const r=Date.now();try{if(!e||!t)return I.UNKNOWN}catch(e){return I.UNKNOWN}return r<(t-=500)?I.VALID:I.EXPIRED}}class H{constructor(e,t){this.scheme=e,this.$storage=t}get(){const e=this.scheme.options.refreshToken.prefix+this.scheme.name;return this.$storage.getUniversal(e)}set(e){const t=S(e,this.scheme.options.refreshToken.type);return this._setToken(t),this._updateExpiration(t),t}sync(){const e=this._syncToken();return this._syncExpiration(),e}reset(){this._setToken(!1),this._setExpiration(!1)}status(){return new R(this.get(),this._getExpiration())}_getExpiration(){const e=this.scheme.options.refreshToken.expirationPrefix+this.scheme.name;return this.$storage.getUniversal(e)}_setExpiration(e){const t=this.scheme.options.refreshToken.expirationPrefix+this.scheme.name;return this.$storage.setUniversal(t,e)}_syncExpiration(){const e=this.scheme.options.refreshToken.expirationPrefix+this.scheme.name;return this.$storage.syncUniversal(e)}_updateExpiration(e){let t;const r=Date.now(),o=1e3*Number(this.scheme.options.refreshToken.maxAge),n=o?r+o:0;try{t=1e3*c(e+"").exp||n}catch(e){if(t=n,!e||"InvalidTokenError"!==e.name)throw e}return this._setExpiration(t||!1)}_setToken(e){const t=this.scheme.options.refreshToken.prefix+this.scheme.name;return this.$storage.setUniversal(t,e)}_syncToken(){const e=this.scheme.options.refreshToken.prefix+this.scheme.name;return this.$storage.syncUniversal(e)}}class j{constructor(e,t){this.scheme=e,this.axios=t,this.interceptor=null}setHeader(e){this.scheme.options.token.global&&this.axios.setHeader(this.scheme.options.token.name,e)}clearHeader(){this.scheme.options.token.global&&this.axios.setHeader(this.scheme.options.token.name,!1)}initializeRequestInterceptor(e){this.interceptor=this.axios.interceptors.request.use((async t=>{if(!this._needToken(t)||t.url===e)return t;const{valid:r,tokenExpired:o,refreshTokenExpired:n,isRefreshable:h}=this.scheme.check(!0);let c=r;if(n)throw this.scheme.reset(),new w;if(o){if(!h)throw this.scheme.reset(),new w;c=await this.scheme.refreshTokens().then((()=>!0)).catch((()=>{throw this.scheme.reset(),new w}))}const l=this.scheme.token.get();if(!c){if(!l&&this._requestHasAuthorizationHeader(t))throw new w;return t}return this._getUpdatedRequestConfig(t,l)}))}reset(){this.axios.interceptors.request.eject(this.interceptor),this.interceptor=null}_needToken(e){const t=this.scheme.options;return t.token.global||Object.values(t.endpoints).some((t=>"object"==typeof t?t.url===e.url:t===e.url))}_getUpdatedRequestConfig(e,t){return"string"==typeof t&&(e.headers[this.scheme.options.token.name]=t),e}_requestHasAuthorizationHeader(e){return!!e.headers.common[this.scheme.options.token.name]}}class A{constructor(e,t){this.scheme=e,this.$storage=t}get(){const e=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.getUniversal(e)}set(e){const t=S(e,this.scheme.options.token.type);return this._setToken(t),this._updateExpiration(t),"string"==typeof t&&this.scheme.requestHandler.setHeader(t),t}sync(){const e=this._syncToken();return this._syncExpiration(),"string"==typeof e&&this.scheme.requestHandler.setHeader(e),e}reset(){this.scheme.requestHandler.clearHeader(),this._setToken(!1),this._setExpiration(!1)}status(){return new R(this.get(),this._getExpiration())}_getExpiration(){const e=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.getUniversal(e)}_setExpiration(e){const t=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.setUniversal(t,e)}_syncExpiration(){const e=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.syncUniversal(e)}_updateExpiration(e){let t;const r=Date.now(),o=1e3*Number(this.scheme.options.token.maxAge),n=o?r+o:0;try{t=1e3*c(e+"").exp||n}catch(e){if(t=n,!e||"InvalidTokenError"!==e.name)throw e}return this._setExpiration(t||!1)}_setToken(e){const t=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.setUniversal(t,e)}_syncToken(){const e=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.syncUniversal(e)}}class L{constructor(e,...t){this.$auth=e,this.options=t.reduce(((p,e)=>l(p,e)),{})}get name(){return this.options.name}}const C={name:"local",endpoints:{login:{url:"/api/auth/login",method:"post"},logout:{url:"/api/auth/logout",method:"post"},user:{url:"/api/auth/user",method:"get"}},token:{property:"token",type:"Bearer",name:"Authorization",maxAge:1800,global:!0,required:!0,prefix:"_token.",expirationPrefix:"_token_expiration."},user:{property:"user",autoFetch:!0},clientId:!1,grantType:!1,scope:!1};class N extends L{constructor(e,t,...r){super(e,t,...r,C),this.token=new A(this,this.$auth.$storage),this.requestHandler=new j(this,this.$auth.ctx.$axios)}check(e=!1){const t={valid:!1,tokenExpired:!1};if(!this.token.sync())return t;if(!e)return t.valid=!0,t;return this.token.status().expired()?(t.tokenExpired=!0,t):(t.valid=!0,t)}mounted({tokenCallback:e=(()=>this.$auth.reset()),refreshTokenCallback:t}={}){const{tokenExpired:r,refreshTokenExpired:o}=this.check(!0);return o&&"function"==typeof t?t():r&&"function"==typeof e&&e(),this.initializeRequestInterceptor(),this.$auth.fetchUserOnce()}async login(e,{reset:t=!0}={}){if(!this.options.endpoints.login)return;t&&this.$auth.reset({resetInterceptor:!1}),this.options.clientId&&(e.data.client_id=this.options.clientId),this.options.grantType&&(e.data.grant_type=this.options.grantType),this.options.scope&&(e.data.scope=this.options.scope);const r=await this.$auth.request(e,this.options.endpoints.login);return this.updateTokens(r),this.requestHandler.interceptor||this.initializeRequestInterceptor(),this.options.user.autoFetch&&await this.fetchUser(),r}setUserToken(e){return this.token.set(e),this.fetchUser()}fetchUser(e){return this.check().valid?this.options.endpoints.user?this.$auth.requestWith(this.name,e,this.options.endpoints.user).then((e=>{const t=$(e.data,this.options.user.property);if(!t){const e=new Error(`User Data response does not contain field ${this.options.user.property}`);return Promise.reject(e)}return this.$auth.setUser(t),e})).catch((e=>(this.$auth.callOnError(e,{method:"fetchUser"}),Promise.reject(e)))):(this.$auth.setUser({}),Promise.resolve()):Promise.resolve()}async logout(e={}){return this.options.endpoints.logout&&await this.$auth.requestWith(this.name,e,this.options.endpoints.logout).catch((()=>{})),this.$auth.reset()}reset({resetInterceptor:e=!0}={}){this.$auth.setUser(!1),this.token.reset(),e&&this.requestHandler.reset()}updateTokens(e){const t=!this.options.token.required||$(e.data,this.options.token.property);this.token.set(t)}initializeRequestInterceptor(){this.requestHandler.initializeRequestInterceptor()}}const z={name:"refresh",endpoints:{refresh:{url:"/api/auth/refresh",method:"post"}},refreshToken:{property:"refresh_token",data:"refresh_token",maxAge:2592e3,required:!0,tokenRequired:!1,prefix:"_refresh_token.",expirationPrefix:"_refresh_token_expiration."},autoLogout:!1};class D extends N{constructor(e,t){super(e,t,z),this.refreshToken=new H(this,this.$auth.$storage),this.refreshController=new P(this)}check(e=!1){const t={valid:!1,tokenExpired:!1,refreshTokenExpired:!1,isRefreshable:!0},r=this.token.sync(),o=this.refreshToken.sync();if(!r||!o)return t;if(!e)return t.valid=!0,t;const n=this.token.status();return this.refreshToken.status().expired()?(t.refreshTokenExpired=!0,t):n.expired()?(t.tokenExpired=!0,t):(t.valid=!0,t)}mounted(){return super.mounted({tokenCallback:()=>{this.options.autoLogout&&this.$auth.reset()},refreshTokenCallback:()=>{this.$auth.reset()}})}refreshTokens(){if(!this.options.endpoints.refresh)return Promise.resolve();if(!this.check().valid)return Promise.resolve();if(this.refreshToken.status().expired())throw this.$auth.reset(),new w;this.options.refreshToken.tokenRequired||this.requestHandler.clearHeader();const e={data:{client_id:void 0,grant_type:void 0}};return this.options.refreshToken.required&&this.options.refreshToken.data&&(e.data[this.options.refreshToken.data]=this.refreshToken.get()),this.options.clientId&&(e.data.client_id=this.options.clientId),this.options.grantType&&(e.data.grant_type="refresh_token"),function(e){for(const t in e)void 0===e[t]&&delete e[t]}(e.data),this.$auth.request(e,this.options.endpoints.refresh).then((e=>(this.updateTokens(e,{isRefreshing:!0}),e))).catch((e=>(this.$auth.callOnError(e,{method:"refreshToken"}),Promise.reject(e))))}setUserToken(e,t){return this.token.set(e),t&&this.refreshToken.set(t),this.fetchUser()}reset({resetInterceptor:e=!0}={}){this.$auth.setUser(!1),this.token.reset(),this.refreshToken.reset(),e&&this.requestHandler.reset()}updateTokens(e,{isRefreshing:t=!1,updateOnRefresh:r=!0}={}){const o=!this.options.token.required||$(e.data,this.options.token.property),n=!this.options.refreshToken.required||$(e.data,this.options.refreshToken.property);this.token.set(o),n&&(!t||t&&r)&&this.refreshToken.set(n)}initializeRequestInterceptor(){this.requestHandler.initializeRequestInterceptor(this.options.endpoints.refresh.url)}}},436:function(e,t,r){(function(e){e.installComponents=function(component,e){var r="function"==typeof component.exports?component.exports.extendOptions:component.options;for(var i in"function"==typeof component.exports&&(r.components=component.exports.options.components),r.components=r.components||{},e)r.components[i]=r.components[i]||e[i];r.functional&&function(component,e){if(component.exports[t])return;component.exports[t]=!0;var r=component.exports.render;component.exports.render=function(t,o){return r(t,Object.assign({},o,{_c:function(t,a,b){return o._c(e[t]||t,a,b)}}))}}(component,r.components)};var t="_functionalComponents"}).call(this,r(8))}}]);